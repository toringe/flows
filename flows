#!/bin/bash
################################################################################
##
## Flows - A simple wrapper around nfdump
## --------------------------------------
##
## Description:
## Simply got tired of searching through various directories and writing long
## tedious dates and other stuff. User may specify various simple parameters to
## change the search criteria. Hard core users will see that this is not a
## complete replacement for using nfdump to search through flows, but it's a 
## more convenient way to do simple searches.
##
## Author: 
## Tor Inge Skaar (tor.inge.skaar|gmail.com)
##
################################################################################

# Configuration
ROOT_FLOW_DIR="/var/log/netflow"
NFDUMP=`which nfdump`
BASE_NFDUMP_CMD="$NFDUMP -O tstart"
CMD_LOG_FILE="/usr/local/log/flows.cmd.log"
USING_NFSEN=true
ALERT_META_PATH="/var/log/nfsen/profiles-stat"
CACHE_DIR="/var/cache/flows/"
CACHE_TIME="14"
TMP_DIR="/tmp/flows"
OUTPUT="fmt:%ts %td %pr %sap -> %dap %sas -> %das %flg %pkt %byt %pps %bps %fl"
FILTERDIR="/usr/local/share/filter"
WIDTH=`tput cols`
LOCALCORES=`cat /proc/cpuinfo | grep processor | wc -l`
CLUSTER="$LOCALCORES/:"
#CLUSTER="4/:,8/flows@node01.local"
PRIVKEY="/usr/local/share/flows/ssh/id_flows"
REVISION="1"

################################################################################

# Configuration check

if [ ! -d $ROOT_FLOW_DIR ]; then
	echo "[ERROR] No netflow directory specified ($ROOT_FLOW_DIR)" >&2
	exit 1
fi
if [ -z $NFDUMP ]; then
	echo "[ERROR] Nfdump binary was not found ($NFDUMP)" >&2;
	exit 1
fi
if [ ! -x $NFDUMP ]; then
	echo "[ERROR] Nfdump binary is not executeable ($NFDUMP)" >&2  
	exit 1
fi
if [ ! -d $FILTERDIR ]; then
	echo "[ERROR] Filter directory not found ($FILTERDIR)" >&2
	exit 1
fi

# Start of execution
t_a=`date +%s`

function printusage {
	echo -e "\nFlows (rev. $REVISION) - A simple wrapper around nfdump\n";
	echo -e "Usage: flows [options] ['Filter']\n";
	echo -e "  Most commonly used options (use -h to show all available options):";
	echo -e "  -a        | --aggr      | Aggregate flow data";
	echo -e "  -d <num>  | --days      | Number of complete days ago (default 1)";
	echo -e "  -E <date> | --end       | End time for flow search: YYYY-mm-dd(-HH)(-MM)";
	echo -e "  -h        | --help      | Show all options (this output is just some of them)";
 	echo -e "  -l        | --list      | List available (active) probes";
	echo -e "  -n <num>  |             | Used with -s to define number (default 10)";
	echo -e "  -p <name> | --probe     | Limit search to a probe name (use multiple -p";
	echo -e "            |             | to specify several probes. Skip to search all)";
	echo -e "  -q        | --quiet     | Suppress meta-output from script and nfdump";
	echo -e "  -r<num>   | --recent    | Search in recent <num> of minutes (default 5).";
	echo -e "            |             | As this has an optional argument, you have to write";
	echo -e "            |             | -r10 (no space between) to search last 10 minutes";
	echo -e "            |             | Note: Cache is not used when using recent-search";
	echo -e "  -s        | --stats     | Generate Top statistics (see nfdump -h)";
	echo -e "  -S <date> | --start     | Start time for flow search: YYYY-mm-dd(-HH)(-MM)";
	echo -e "  -t <slot> | --timeslot  | Provide a single timeslot interval (YYYYmmddHHMM) to";
	echo -e "            |             | search in. This option has precedence over S/E and d";
	echo -e "  -T <trig> | --trigger   | Used to dig into alerts generated by Nfsen. Simply";
	echo -e "            |             | specify the triggername as input (use nfalert -l to";
	echo -e "            |             | list available triggers). You can also use the whole";
	echo -e "            |             | trigger-string with timestamp included to search";
	echo -e "            |             | only in that timeframe <trigger-name>@<timestamp>";
	echo -e "\n  Filter:  \n  \tnfdump has a powerful and fast filter engine. All flow are filtered";
	echo -e "  \tbefore they are further processed. If no filter is given, any flow";
	echo -e "  \twill be processed. The filter is specified on the command line as";
 	echo -e "  \tlast argument enclosed in \'. The filter syntax used is heavily";
	echo -e "  \tbased on standard BPF syntax. Filter specified on the command line";
	echo -e "  \twill always override -f.";
	echo -e "\n  Examples:\n  \tflows 'srcip 192.168.1.2 and port 443'";
	echo -e "\tflows -d5 \"net 10.20.30.0/24\"";
	echo -e "\tflows -p router01 -vd7 -s srcip";
	echo -e "\tflows -S 2008-12-24-15-35 -E 2008-12-28 \"host google.com\"";
	echo -e "\tflows -p router04 -r30 \"as 1234\"";
	echo "";
	exit 1
}

function print_full_usage {
	echo -e "\nFlows (rev. $REVISION) - A simple wrapper around nfdump\n"
	echo -e "Usage: flows [options] ['Filter']\n"
	echo -e "  Options:"
	echo -e "  -24       |             | Same as -r1440"
	echo -e "  -a        | --aggr      | Aggregate flow data"
	echo -e "  -C        | --color     | Use colors in output to terminal"
	echo -e "  -cc <c,t> | --country   | Specify ISO-3166-1 alpha-2 country code as a"
	echo -e "            |             | filter (c). And set type (t) to either ASN or IP."
	echo -e "            |             | It defaults to ASN if no type is set" 
	echo -e "  -d <num>  | --days      | Number of complete days ago (default 1)"
	echo -e "  -E <date> | --end       | End time for flow search: YYYY-mm-dd(-HH)(-MM)"
	echo -e "  -f <file> | --filter    | Path to filter file (use multiple -f to specify"
	echo -e "            |             | several files which will be combined)"
	echo -e "  -h        | --help      | You're looking at it! (You may also consult the"
	echo -e "            |             | man pages for this command, by running \"man flows\""
	echo -e "  -H        | --hitsonly  | Output only results with flow hits"
	echo -e "  -i        |             | Use intersection when combining multiple filter"
	echo -e "            |             | files with -f or -cc (default behaviour is union)"
	echo -e "  -j        |             | Disable parallel execution"
	echo -e "  -J        |             | Disable cluster execution when running in parallel"
 	echo -e "  -l        | --list      | List available (active) probes"
	echo -e "  -L        | --last      | List last 10 flows commands used"
	echo -e "  -n <num>  |             | Used with -s to define number (default 10)"
	echo -e "  -N        | --nfresolve | Let nfdump do DNS resolution"
	echo -e "  -o <type> | --output    | Output format [raw,line,long,extended,pipe,fmt]"
	echo -e "  -p <name> | --probe     | Limit search to a probe name (use multiple -p"
	echo -e "            |             | to specify several probes. Skip to search all)"
	echo -e "  -P <a:v>  | --proxy     | Proxy argument:value to nfdump"
	echo -e "  -q        | --quiet     | Suppress meta-output from script and nfdump"
	echo -e "  -r<num>   | --recent    | Search in recent <num> of minutes (default 5)."
	echo -e "            |             | As this has an optional argument, you have to write"
	echo -e "            |             | -r10 (no space between) to search last 10 minutes"
	echo -e "            |             | Note: Cache is not used when using recent-search"
	echo -e "  -R        | --no-cache  | Do not use result cache"
	echo -e "  -s <type> | --stats     | Generate Top statistics (see nfdump -h)"
	echo -e "  -S <date> | --start     | Start time for flow search: YYYY-mm-dd(-HH)(-MM)"
	echo -e "  -t <slot> | --timeslot  | Provide a single timeslot interval (YYYYmmddHHMM) to"
	echo -e "            |             | search in. This option has precedence over S/E and d"
	echo -e "  -T <trig> | --trigger   | Used to dig into alerts generated by Nfsen. Simply";
	echo -e "            |             | specify the triggername as input (use nfalert -l to";
	echo -e "            |             | list available triggers). You can also use the whole";
	echo -e "            |             | trigger-string with timestamp included to search";
	echo -e "            |             | only in that timeframe <trigger-name>@<timestamp>";
	echo -e "  -v        | --verbose   | More verbose script output (debug). Several v's may"
	echo -e "            |             | be specified to get even more debugging output"
	echo -e "  -V        | --version   | Print script revision number"
	echo -e "  -x        |             | Output awesome ascii-art header!"
	echo -e "\n  Filter:  \n  \tnfdump has a powerful and fast filter engine. All flow are filtered"
	echo -e "  \tbefore they are further processed. If no filter is given, any flow"
	echo -e "  \twill be processed. The filter is specified on the command line as"
 	echo -e "  \tlast argument enclosed in \'. The filter syntax used is heavily"
	echo -e "  \tbased on standard BPF syntax. Filter specified on the command line"
	echo -e "  \twill always override -f."
	echo -e "\n  Examples:\n  \tflows 'srcip 192.168.1.2 and port 443'"
	echo -e "\tflows -d5 \"net 10.20.30.0/24\""
	echo -e "\tflows -p router01 -vd7 -s srcip";
	echo -e "\tflows -S 2008-12-24-15-35 -E 2008-12-28 \"host google.com\"";
	echo -e "\tflows -p router04 -r30 \"as 1234\"";
	echo ""
	exit 1
}

##
# Print debug messages if flag is enabled
#
function debug {
	if [ $verbose -ne 0 ]; then
		echo "[DEBUG] $1" >&2
	fi
}
##
# Output a list of all active probes. (From the database)
#
function list_probes {
	list=`ls -l $ROOT_FLOW_DIR | grep -e "^d" | awk '{print $9}'`;
	if [ -z "$list" ]; then
		echo "[ERROR] Failed to retrive a list of probes" >&2
		exit 1;
	fi
	for p in $list; do
		echo $p;
	done;
}

##
# Output the last 10 flows commands
#
function show_last_cmds {
	if [ ! -e $CMD_LOG_FILE ]; then
		echo "[WARNING] $CMD_LOG_FILE does not exist" >&2
		exit 1
	fi
	if [ ! -r $CMD_LOG_FILE ]; then
		echo "[WARNING] $CMD_LOG_FILE is not readable" >&2
		exit 1
	fi
	echo "Last 10 flows commands used on `hostname`:";
	echo "";
	tail -n 10 $CMD_LOG_FILE | cut -d\; -f3
	echo "";
}

##
# Output version number
#
function show_version {
	echo "Flows revision number: $REVISION";
}

##
# Check if input string is an IP
#
function is_IP {
	cmd="echo '$1' | egrep -c \"^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$\"";
	ip=`eval $cmd`;
	if [ $ip -eq 1 ]; then
		return 1;
	else
		return 0;
	fi
}

##
# Resolve all domains in the given filter (input parameter), i.e. get their IP addresses.
# Domains that resolve to many IPs are expanded in the filter. Domains that do not resolve
# are functionally removed from the filter by setting the host string to IF 0. This was the
# easiest hack, without breaking the filter in √ºber-complex parsing.
#
function resolve {
	hosts="";
	tmp=`echo $1 | tr [:upper:] [:lower:] | egrep -o "host [a-z√¶√∏√•0-9.\_\\-]+" | sed 's/^host //g'`;
	for h in $tmp; do
		is_IP "$h";
		if [ $? -eq 0 ]; then
			hosts=${hosts}${h}" ";
		fi
	done
	if [ -n "$hosts" ]; then
		for host in $hosts; do
			output=`host -t A $host | grep "has address"`;
			if [ $? -eq 0 ]; then
				declare -a ips;
				ORGIFS=$IFS
				IFS=`echo -en "\n\b"`;
				for line in $output; do
					ip=`echo $line | awk '{print $4}'`;
					ips=( "${ips[@]}" $ip );
				done
				IFS=$ORGIFS;
				if [ ${#ips[@]} -gt 1 ]; then
					for (( i=0; i < ${#ips[@]}; i++ )); do
						ipstxt=$ipstxt"ip "${ips[$i]}" or ";
					done
					ipstxt=`echo $ipstxt | sed 's/ or$//g'`;
				else
					ipstxt="ip "${ips[0]};
				fi
				cmd="echo \"$filter\" | sed 's/host $host/$ipstxt/g'";
				filter=`eval $cmd`;
				unset ips ipstxt
			else
				echo "[WARNING] Failed to resolve $host. Inserting IF 0 as substitute" >&2;
				cmd="echo \"$filter\" | sed 's/host $host/IF 0/g'";
				filter=`eval $cmd`;
			fi
		done
	fi	
}

##
# Syntax check of the timeslot definition.
#
function ts_check {
	tcheck=`echo $timeslot | grep -c -e "^[0-9]\{12\}$"`
	if [ $tcheck -eq 0 ]; then
		tcheck=`echo $timeslot | grep -c -e "^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\} [0-9]\{2\}:[0-9]\{2\}$"`
		if [ $tcheck -eq 0 ]; then
			echo "[ERROR] Invalid format. Use YYYYMMDDHHmm or \"YYYY-MM-DD HH:mm\"" >&2
			exit 1;
		else
			# Reformat input
			timeslot=`echo $timeslot | tr -d "\-: "`;
		fi
	fi
}

##
# Determine the timestamp of the most current data.
# After calling this function, the time can be found in the
# variable "LAST_AVAIL_DATA"
#
function last_avail_data {
	
	now=`date "+%Y-%m-%d-%H-%M-%S"`
	if [ $verbose -ge 1 ]; then
		echo "[DEBUG] Now: $now" >&2
	fi
	now_Y=`echo $now | cut -d- -f1`;
	now_m=`echo $now | cut -d- -f2`;
	now_d=`echo $now | cut -d- -f3`;
	now_H=`echo $now | cut -d- -f4`;
	now_M=`echo $now | cut -d- -f5`;
	now_M1=${now_M:0:1};
	now_M2=${now_M:1:1};
	data_Y=$now_Y; data_m=$now_m; data_d=$now_d; data_H=$now_H; data_M1=$now_M1; data_M2=$now_M2;

	if [ $now_M2 -ge 0 -a $now_M2 -le 4 ]; then
		data_M2=5
		data_M1=$(( now_M1 - 1 ))
		if [ $data_M1 -lt 0 ]; then
			data_M1=5
			data_H=$(( now_H - 1 ))
			if [ $verbose -ge 1 ]; then
				echo "[DEBUG] Adjusted hour to: $data_H" >&2
			fi
			if [ $data_H -lt 10 -a $data_H -ge 0 ]; then
				data_H="0"$data_H
			elif [ $data_H -lt 0 ]; then
				data_H=23;
				data_d=$(( now_d - 1 ))
				if [ $verbose -ge 1 ]; then
					echo "[DEBUG] Adjusted day to: $data_d" >&2
				fi
				if [ $data_d -lt 10 -a $data_d -gt 0 ]; then
					data_d="0"$data_d
				elif [ $data_d -eq 0 ]; then
					data_d=`date -d "yesterday" +%d`
					data_m=`date -d "yesterday" +%m`
					data_Y=`date -d "yesterday" +%Y`
					if [ $verbose -ge 1 ]; then
						echo "[DEBUG] Flipped date to: $data_d-$data_m-$data_Y" >&2
					fi
				fi
			fi
		fi
	elif [ $now_M2 -ge 5 -a $now_M2 -le 9 ]; then
		data_M2=0
	else
		if [ $useguru -eq 1 ]; then
			guru 2
		else
			echo "[ERROR] Internal error 2" >&2
			exit 1
		fi
	fi
	# Make sure collector has had time to relocate data file to hierarcy
	now_S=`echo $now | cut -d- -f6`
	now_S1=${now_S:0:1}
	if [ $now_M2 -eq 0 -o $now_M2 -eq 5 ]; then
		if [ $now_S1 -eq 0 ]; then
			if [ $verbose -ge 1 ]; then
				echo "[DEBUG] Sleeping 5 sec to allow collector to flush data" >&2
			fi
			sleep 5
		fi
	fi
	LAST_AVAIL_DATA=$data_Y"-"$data_m"-"$data_d" "$data_H":"${data_M1}${data_M2}
	if [ $verbose -ge 1 ]; then
		echo "[DEBUG] Last available data @ $LAST_AVAIL_DATA" >&2
	fi
}

##
# Aligns the given timestamp (YYYY-mm-dd-HH-MM) to the lower 0 or 5.
# Note that this function takes a variable reference as input, i.e.
# the name of the variable, and not its value. E.g align_time myvar
# and not align_time $myvar
#
function align_time {

	time_in=${!1}
	check=`echo $time_in | grep -c -e "^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}-[0-9]\{2\}-[0-9]\{2\}$"`
	if [ $check -eq 0 ]; then
		echo "[ERROR] Invalid syntax on input time in function align_time" >&2
	fi
	if [ $verbose -ge 1 ]; then
		echo "[DEBUG] Input time: $time_in" >&2
	fi
	t_M=`echo $time_in | cut -d- -f5`
	t_M1=${t_M:0:1}
	t_M2=${t_M:1:1}
	if [ $t_M2 -ge 1 -a $t_M2 -le 4 ]; then
		t_M2=0
	elif [ $t_M2 -ge 6 -a $t_M2 -le 9 ]; then
		t_M2=5
	fi
	time_aligned=`echo $time_in | cut -d- -f1-4`"-"${t_M1}${t_M2};                                    
	if [ $verbose -ge 1 ]; then
		echo "[DEBUG] Aligned time: $time_aligned" >&2
	fi
	eval "$1=$time_aligned"
}

##
# Defining a proper search window for the recent X minutes.
# Input argument to this function is the value of X. The function
# will properly set the variable "customstart".
#
function recent {

	rtime=$1
	if [ $rtime -le 0 ]; then
    	echo "[ERROR] Recent-search must be non-zero and positive" >&2
    	exit 1
	fi
    if [ $rtime -gt 1440 ]; then
    	echo "[ERROR] Recent-search upper limit is 24h (1440 min)" >&2
        exit 1
    fi

	# Get timestamp of most current data
	last_avail_data

	# Determine start time of the requested search
	dtime1=`date -d "$LAST_AVAIL_DATA" +"%s"`
	dtime2=$(( dtime1 + 300 ))
	rtime_real=$(( dtime2 - ( rtime * 60 ) ))
	rtime_real=`date -d "@$rtime_real" +"%Y-%m-%d-%H-%M"`

	# Align time
	align_time rtime_real

	customstart=$rtime_real
}

##
# Print a given text using the awesome toilet library!
#
function flush {

	text=$1
	if [ -z "$text" ]; then
		return 1
	fi	
	toilet=`which toilet`
	fontdir="/usr/share/figlet"
	badfont="bigmono12|circle|mono12|smbraille"

	# Select random font
	cmd="find $fontdir -type f | egrep -v \"$badfont\" | sort -R | basename \`tail -1\` | cut -d. -f1"
	font=`eval $cmd`
	
	# Select random style
	style=`echo -e "metal\ngay\nnone" | sort -R | tail -1`
	if [ "$style" = "none" ]; then
		style=""
	else
		style="--"$style
	fi

	$toilet -f $font $style $text	
}

################################################################################

# Default parameter values
r24=0;              # -24 
logo=0;             # -x
fuse=0;             # Filter specified on CLI
duse=0;             # -d
ouse=0;             # -o
ause=0;             # -a
suse=0;             # -s
ffuse=0;            # -f (filter file specified)
quiet=0;            # -q
verbose=0;          # -v
nocolor=1;          # -C
nocache=0;          # -r / -R / -24
hitsonly=0;         # -H
union=1;            # -i
nfresolve=0;        # -N
parallel=1;         # -j
nocluster=0;        # -J
DEFAULT_TIME=1;     # Default number of days ago
declare -a ffiles   # Array containing file paths

# Use guru errors if lib available
if [ -r /usr/local/lib/guru.sh ]; then
	source "/usr/local/lib/guru.sh"
	useguru=1
else
	useguru=0
fi

# No options, no fun...
if [ $# -eq 0 ]; then printusage; fi

# Create temporary working dir
mkdir -p $TMP_DIR 
if [ $? -ne 0 ]; then
	echo "[ERROR] Failed to create temporary working directory: $TMP_DIR" >&2
	exit 1
fi

# If you add new options, remember to update the OPTSTRING below. Single colon
# following the option specifies required argument, double colon is optional 
# argument, while no colon defines that this option has no argument.

_ARGS=`getopt -a -o aCd:E:f:hHijJlLn:No:p:P:qr::Rs:S:t:T:vVx -l 24,aggr,color,cc:,country:,days:,end:,filter:,guru,help,hitsonly,list,last,nfresolve,output:,probe:,proxy:,quiet,recent::,no-cache,stats:,start:,timeslot:,trigger:,verbose,vv,version -n 'flows' -- "$@"`
if [ $? != 0 ]; then 
	echo "[ERROR] Parsing of command options failed" >&2 ;
	printusage;
fi
eval set -- "$_ARGS"

# Process defined options and arguments
cmdlog=`basename $0`
cmdsig=""
days=0
while true ; do
	case "${1}" in
		-h | --help)
			print_full_usage;
			shift
			;;
		-d | --days)
			days=$2;
			timestr="$2 days ago";
			duse=1;
			cmdlog=$cmdlog" -d $2"
			cmdsig=$cmdsig" -d $2"
			shift 2
			;;
		-p | --probe)
			probe="$2";
			plist=( "${plist[@]}" $probe );
			cmdlog=$cmdlog" -p $2"
			cmdsig=$cmdsig" -p $2"
			shift 2
			;;
		-s | --stats)
			spm="-s $2";
			suse=1;
			cmdlog=$cmdlog" -s $2"
			cmdsig=$cmdsig" -s $2"
			shift 2
			;;
		-o | --output) 
			opm="-o $2";
			ouse=1;
			cmdlog=$cmdlog" -o $2"
			cmdsig=$cmdsig" -o $2"
			shift 2
			;;
		-v | --verbose)
			verbose=1;
			cmdlog=$cmdlog" -v"
			shift
			;;		
		--vv )
			verbose=2;
			cmdlog=$cmdlog" -vv"
			shift
			;;		
		-n)
			npm="-n $2";
			cmdlog=$cmdlog" -n $2"
			cmdsig=$cmdsig" -n $2"
			shift 2
			;;
		-N | --nfresolve)
			nfresolve=1;
			cmdlog=$cmdlog" -N"
			cmdsig=$cmdsig" -N"
			shift
			;;
		-q | --quiet)
			quiet=1;
			qpm="-q";
			cmdlog=$cmdlog" -q"
			cmdsig=$cmdsig" -q"
			shift
			;;
		--guru)
			if [ $useguru -eq 1 ]; then
				guru 0
			else
				echo "No guru here..."
			fi
			shift
			;;
		-a | --aggr)
			apm="-a";
			ause=1;	
			cmdlog=$cmdlog" -a"
			cmdsig=$cmdsig" -a"
			shift
			;;
		-l | --list)
			list_probes;
			exit 0
			shift
			;;	
		-f | --filter)
			ffpath=$2;
			if [ ! -r $ffpath ]; then
				echo "[ERROR] Cannot read filter file: $ffpath" >&2
				exit 1
			fi
			fpm=$fpm" -f $ffpath";
			ffiles=( "${ffiles[@]}" $ffpath );
			ffuse=1;
			cmdlog=$cmdlog" -f $2"
			cmdsig=$cmdsig" -f $2"
			shift 2
			;;
		-V | --version)
			show_version;
			exit 0
			shift
			;;
		-S | --start)
			customstart=$2;
			dcheck=`echo $customstart | grep -c -e "^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\(-[0-9]\{2\}\)\?\(-[0-9]\{2\}\)\?$"`
			if [ $dcheck -eq 0 ]; then
				echo "[ERROR] Invalid start date, use: YYYY-MM-DD(-HH)(-ii)" >&2
				exit 1;
			fi
			smin=`echo $customstart | cut -d- -f5`;
			if [ -n "$smin" ]; then
				if [ ${smin:1:1} -ne 0 -a ${smin:1:1} -ne 5 ]; then
					echo "[ERROR] When specifying minutes in start date, it must be aligned on 0 or 5" >&2
					exit 1;
				fi
			fi
			cmdlog=$cmdlog" -S $customstart"
			cmdsig=$cmdsig" -S $customstart"
			shift 2
			;;
		-E | --end)
			customend=$2;
			dcheck=`echo $customend | grep -c -e "^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\(-[0-9]\{2\}\)\?\(-[0-9]\{2\}\)\?$"`
			if [ $dcheck -eq 0 ]; then
				echo "[ERROR] Invalid end date, use: YYYY-MM-DD(-HH)(-ii)" >&2
				exit 1;
			fi
			emin=`echo $customend | cut -d- -f5`;
			if [ -n "$emin" ]; then
				if [ ${emin:1:1} -ne 0 -a ${emin:1:1} -ne 5 ]; then
					echo "[ERROR] When specifying minutes in end date, it must be aligned on 0 or 5" >&2
					exit 1;
				fi
			fi
			cmdlog=$cmdlog" -E $customend"
			cmdsig=$cmdsig" -E $customend"
			shift 2
			;;
		-L | --last)
			show_last_cmds;
			exit 0
			shift
			;;
		-C | --color)
			nocolor=0;
 			cmdlog=$cmdlog" -C"
			shift
			;;
		-j )
			parallel=0;
 			cmdlog=$cmdlog" -j"
			shift
			;;
		-J )
			nocluster=1
			cmdlog=$cmdlog" -J"
			shift
			;;
		-r | --recent)
			rtime=$2
			nocache=1;
			if [ -z "$rtime" ]; then
				rtime=5
			fi
			recent $rtime			
			cmdlog=$cmdlog" -r $rtime"
			shift 2
			;;
		-R | --no-cache)
			nocache=1;
			cmdlog=$cmdlog" -R"
			shift
			;;
		--24)
			nocache=1;
			r24=1
			recent 1440
			cmdlog=$cmdlog" -24"
			shift	
			;;
		-t | --timeslot)
			timeslot=$2;
			ts_check;
			cmdlog=$cmdlog" -t $timeslot"
			cmdsig=$cmdsig" -t $timeslot"
			shift 2
			;;	
		-T | --trigger)
			if [ !$USING_NFSEN ]; then
				echo "[ERROR] Nfsen functionality has been disabled (see configuration)" >&2
				exit 1;
			fi
			trigvalue=$2;
			Tcheck=`echo $trigvalue | grep -c -e "^[0-9A-Za-z_]*@[0-9]\{12\}$"`
			if [ $Tcheck -eq 0 ]; then
				Tcheck=`echo $trigvalue | grep -c -e "^[0-9A-Za-z_]*$"`
				if [ $Tcheck -eq 0 ]; then
					echo "[ERROR] Invalid trigger syntax. Use \"<trigger_name>[@YYYYMMDDHHmm]\"" >&2
					exit 1;
				fi
				trigname="$trigvalue"
			else
				trigname=`echo $trigvalue | cut -d@ -f1`;
				timeslot=`echo $trigvalue | cut -d@ -f2`;	
			fi
			ffpath="$ALERT_META_PATH/~$trigname/$trigname-filter.txt";
			if [[ ! -r "$ffpath" ]]; then
				ffpath="$ALERT_META_PATH/~$trigname*"
				tcount=`ls -d $ffpath 2>/dev/null | wc -l`
				if [ $tcount -eq 0 ]; then
					echo "[ERROR] Unable to find trigger with name: ${trigname}. Check with nfalert -l" >&2
					exit 1;
				fi
				if [ $tcount -gt 1 ]; then
					echo "[ERROR] Trigger name is too ambiguous. There are $tcount triggers matching:" >&2
					for f in `ls -d $ffpath`; do
						echo $f | cut -d~ -f2 | sed 's/^/ * /g';
					done
					exit 1;
				fi
				trigname=`ls -d $ffpath | cut -d~ -f2`
				ffpath="$ALERT_META_PATH/~$trigname/$trigname-filter.txt";
			fi
			fpm=" -f $ffpath";
			ffiles=( "${ffiles[@]}" $ffpath );
			ffuse=1;
			cmdlog=$cmdlog" -T $2"
			cmdsig=$cmdsig" -T $2"
			shift 2
			;;
		-P | --proxy)
			double=`echo $2 | egrep -c ","`
			if [ $double -eq 1 ]; then
				p_arg=`echo $2 | cut -d: -f1`;
				p_val=`echo $2 | cut -d: -f2`;
				proxy=$proxy" -"$p_arg" "$p_val;
			else
				proxy=$proxy" -"$2	
			fi
			cmdlog=$cmdlog" -P $2"
			cmdsig=$cmdsig" -P $2"
			shift 2
			;;
		-x)
			logo=1
			cmdlog=$cmdlog" -x"
			shift
			;;
		--cc | --country)
			double=`echo $2 | egrep -c ","`
			if [ $double -eq 1 ]; then
				cc=`echo $2 | cut -d, -f1 | tr "[:lower:]" "[:upper:]" | egrep "^[A-Z]{2}$"`
				if [ $? -ne 0 ]; then
					echo "[ERROR] Invalid country code. Use ISO-3166-1 alpha-2 codes." >&2
					exit 1
				fi
				cctype=`echo $2 | cut -d, -f2 | tr "[:lower:]" "[:upper:]" | egrep "^(ASN|IP)$"`
				if [ $? -ne 0 ]; then
					echo "[ERROR] Invalid country filter type. Must be either ASN or IP." >&2
					exit 1
				fi
			else
				cc=`echo $2 | tr "[:lower:]" "[:upper:]" | egrep "^[A-Z]{2}$"`
				if [ $? -ne 0 ]; then
					echo "[ERROR] Invalid country code. Use ISO-3166-1 alpha-2 codes." >&2
					exit 1
				fi
				cctype="ASN"
			fi
		
			ffpath=$FILTERDIR"/country/"$cc"."$cctype".filter"
			if [ ! -r $ffpath ]; then
				echo "[ERROR] Country filter not readable ($ffpath)" >&2
				exit 1
			fi
			fpm=$fpm" -f $ffpath";
			ffiles=( "${ffiles[@]}" $ffpath );
			ffuse=1;
			cmdlog=$cmdlog" -cc $2"
			cmdsig=$cmdsig" -cc $2"
			shift 2
			;;
		-i)
			union=0;
			cmdlog=$cmdlog" -i"
			cmdsig=$cmdsig" -i"
			shift
			;;
		-H | --hitsonly )
			hitsonly=1
			cmdlog=$cmdlog" -H"
			cmdsig=$cmdsig" -H"
			shift
			;;
		--) 
			filter=$2;
			shift; 
			break ;;
		 *) echo "[ERROR] Undefined $1" ; exit 1 ;;
	esac;
done;

cmdlog=$cmdlog" \"$filter\""
cmdsig=$cmdsig" \"$filter\""

# Execution ID
eid=`date +"%s"`
debug "Execution ID set to $eid"

fcount=${#ffiles[@]}

# Merge multiple filter files
debug "Size of filter file array: $fcount"
if [ $fcount -gt 1 ]; then
	if [ $union -eq 1 ]; then
		debug "Union of multiple filter files (default behaviour)"
		mop="or"
	else
		debug "Intersection of multiple filter files (-i)"
		mop="and"
	fi

	fmerge=$TMP_DIR/$eid".merge.filter"
	echo "" > $fmerge
	if [ ! -e $fmerge ]; then
		echo "[ERROR] Failed to create $fmerge" >&2
		exit 1
	fi
	for (( fi = 0 ; fi < ${#ffiles[@]} ; fi++ )); do
		content=$( cat ${ffiles[$fi]} | sed 's/#.*$//' | sed 's/^[ \t]*//;s/[ \t]*$//' ) 
		if [ -z "$content" ]; then
			echo "[WARNING] Empty filter file: ${ffiles[$fi]}" >&2
			continue
		fi
		echo -n "( " >> $fmerge
		echo "$content" | sed ':a;N;$!ba;s/\n/ /g' >> $fmerge
		echo -n " ) $mop " >> $fmerge
	done
	cat $fmerge | sed "s/ $mop $//g" > $TMP_DIR/$eid".merge.last"
	mv $TMP_DIR/$eid".merge.last" $fmerge
	fpm=" -f $fmerge"
fi
if [ $verbose -ge 1 -a -n "$fpm" ]; then
	tmpffile=`echo "$fpm" | awk '{print $2}'`
	tmpfstring=`cat $tmpffile | sed 's/#.*$//' | sed ':a;N;$!ba;s/\n/ /g'`
	debug "Filter string: $tmpfstring"
fi

# Argument post-processing and command overrides
if [ $logo -eq 1 ]; then
	which toilet &>/dev/null
	if [ $? -ne 0 ]; then
		echo "[WARNING] TOIlet not located!" >&2
		logo=0
	else
		flush `basename $0`
	fi
fi
if [ $suse -eq 1 ]; then apm=""; fi
if [ $quiet -eq 1 ]; then verbose=0; fi
if [ $r24 -eq 1 ]; then debug "Entering Jack-Bauer-mode!"; fi
if [ $hitsonly -eq 1 ]; then nocolor=1; fi
if [[ $parallel -eq 0 && $nocluster -eq 1 ]]; then
	echo "[ERROR] It makes no sense to use both -j and -J at the same time" >&2
	exit 1
fi


# Check if command log exists
if [ ! -e $CMD_LOG_FILE ]; then
	debug "Creating $CMD_LOG_FILE"
	touch $CMD_LOG_FILE >/dev/null 2>&1;
	if [ $? -ne 0 ]; then
		echo "[ERROR] Failed to create $CMD_LOG_FILE" >&2
		exit 1
	fi
fi
if [ -w $CMD_LOG_FILE ]; then
	debug "Logging commands to $CMD_LOG_FILE"
	do_log=1;
else
	echo "[WARNING] Command log file not writeable ($CMD_LOG_FILE)" >&2
	do_log=0;
fi

# Deal with caching
if [ $nocache -eq 0 ]; then

	# Cache directory maintainance
	debug "Cache directory: $CACHE_DIR"
	if [ ! -d $CACHE_DIR ]; then
		mkdir -p $CACHE_DIR
		if [ $? -eq 0 ]; then
			debug "Cache directory $CACHE_DIR created"
		else
			echo "[WARNING] Failed to create cache directory $CACHE_DIR" >&2
		fi
	else
		obsolete=$( find $CACHE_DIR -type f -mtime +$CACHE_TIME | wc -l )
		if [ $obsolete -gt 0 ]; then
			debug "Cache cleanup ($obsolete files are older than $CACHE_TIME days)"
			find $CACHE_DIR -type f -mtime +$CACHE_TIME -exec rm -f {} \;
			if [ $? -ne 0 ]; then
				echo "[WARNING] Failed to clean cache" >&2
			fi
		fi
	fi

	# Create a signature representing this execution (current set of params)
	cmdsig=`echo $cmdsig | sed 's/^ //g'`
	debug "Input to signature: $cmdsig"
	runtimesig=`echo "$cmdsig" | md5sum | awk '{print $1}'`;
	debug "Runtime signature: $runtimesig"
	if [ ! -w $CACHE_DIR ]; then
		echo "[ERROR] Cache directory $CACHE_DIR not writeable. Fix it, or use -R." >&2;
		exit 1;
	else
		if [ -r $CACHE_DIR"/"$runtimesig ]; then

			# Cache hit!
			echo "Using Cache: "$runtimesig;
			cat $CACHE_DIR"/"$runtimesig;
			if [ $nocolor -eq 0 ]; then
				echo -e "\n\033[36;1m*** CACHED DATA ***\033[0m\n"
			else
				echo -e "\n*** CACHED DATA ***\n";
			fi
			exit 0;
		fi
	fi
else
	debug "Result cache is disabled"
fi

if [ $ouse -eq 0 ]; then
	# No output format specified. Default to my custom format!
	opm="-o \"$OUTPUT\"";
fi

# Calculating time parameters

customstart_full=$customstart;
customend_full=$customend;
customstart=`echo $customstart | cut -d- -f1-3`; 
customend=`echo $customend | cut -d- -f1-3`; 

if [ -n "$customstart" ]; then
	# Custom start has been defined
	if [ -n "$customend" ]; then
		# Custom end has also been defined
		timestart=$customstart;
		timeend=$customend;
	elif [ $duse -eq 1 ]; then
		# Days parameter defined
		startint=`date -d "$customstart" +"%s"`;
		endint=$(( startint + days * 86400 ));
		timestart=$customstart;
		timeend=`date -d "@$endint" +"%Y-%m-%d"`;
	else
		# Defaulting to end = now
		timestart=$customstart;
		timeend=`date +"%Y-%m-%d"`;
	fi
else
	# No custom start
	if [ -n "$customend" ]; then
		# Custom end has been defined
		if [ $duse -eq 1 ]; then
			# Days parameter defined
			endint=`date -d "$customend" +"%s"`;
			startint=$(( endint - days * 86400 ));
			timestart=`date -d "@$startint" +"%Y-%m-%d"`;
			timeend=$customend;
		else
			# Defaulting to DEFAULT_TIME
			endint=`date -d "$customend" +"%s"`;
			startint=$(( endint - DEFAULT_TIME * 86400 ));
			timestart=`date -d "@$startint" +"%Y-%m-%d"`;
			timeend=$customend;
		fi
	else
		# No custom end
		if [ $duse -eq 1 ]; then
			# Days parameter defined
			endint=`date +"%s"`;
			startint=$(( endint - days * 86400 ));
			timestart=`date -d "@$startint" +"%Y-%m-%d"`;
			timeend=`date -d "@$endint" +"%Y-%m-%d"`;
		else
			# Defaulting to DEFAULT_TIME
			endint=`date +"%s"`;
			startint=$(( endint - DEFAULT_TIME * 86400 ));
			timestart=`date -d "@$startint" +"%Y-%m-%d"`;
			timeend=`date -d "@$endint" +"%Y-%m-%d"`;
		fi
	fi
fi

# Calculating start data
sdir=`date -d "$timestart" +"%Y/%m/%d"`;
ts=`echo $customstart_full | cut -d- -f4-5`;
if [ -n "$ts" ]; then
	ts=`echo $ts | tr -d "-"`;
	if [ ${#ts} -eq 2 ]; then
		ts=$ts"00";
	fi
else
	ts="0000";
fi
sfile="nfcapd."`date -d "$timestart" +"%Y%m%d"`"$ts";

# Calculating end data
edir=`date -d "$timeend" +"%Y/%m/%d"`;
te=`echo $customend_full | cut -d- -f4-5`;
if [ -n "$te" ]; then
	te=`echo $te | tr -d "-"`;
	if [ ${#te} -eq 2 ]; then
		te=$te"59";
	fi
else
	te="2359";
fi
efile="nfcapd."`date -d "$timeend" +"%Y%m%d"`"$te";

# -t option has precedence
if [ -n "$timeslot" ]; then
	Y=`echo ${timeslot:0:4}`;
	M=`echo ${timeslot:4:2}`;
	D=`echo ${timeslot:6:2}`;
	sdir=$Y"/"$M"/"$D;
	edir=$sdir;
	sfile="nfcapd."$timeslot;
	efile=$sfile;
fi
	
# List of probes the user asked for
if [ ${#plist[@]} -gt 0 ]; then
	if [ $quiet -eq 0 ]; then
		searchon="on: ${plist[@]}";
	fi
	pstring="";
	for (( pi = 0 ; pi < ${#plist[@]} ; pi++ )); do
		pstring=$pstring"|"${plist[$pi]};
	done;
	pstring=`echo $pstring | sed '1s/^.//'`;
else
	if [ $quiet -eq 0 ]; then
		searchon="on all probes";
	fi
	pstring="";
fi

# Get actual probe names of those available
list=`ls -l $ROOT_FLOW_DIR | grep -e "^d" | awk '{print $9}' | egrep -i "$pstring"`;
if [ -z "$list" ]; then
	echo "[ERROR] None of the probes you've asked for exists!" >&2
	exit 1
fi

# Prepare for parallel execution
if [ $parallel -eq 1 ]; then
	if [ $nocluster -eq 0 ]; then
		if [ ! -d ~/.ssh ]; then
			debug "Creating ~/.ssh directory"
			mkdir ~/.ssh
		else
			debug "~/.ssh directory exists"
		fi
		if [ ! -r ~/.ssh/id_flows ]; then
			if [ ! -e $PRIVKEY ]; then
				echo "[ERROR] Private key does not exists ($PRIVKEY)" >&2
				exit 1
			fi
			debug "Adding id_flows private key to your ~/.ssh/ directory"
			cp $PRIVKEY ~/.ssh/
			chmod 600 ~/.ssh/id_flows
		else
			debug "Found id_flows private key"
		fi
		if [ -f ~/.ssh/config ]; then
			cfgstatus=$( egrep -c "IdentityFile.*id_flows" ~/.ssh/config )
			cfganswer=$( egrep -c "IdentityFile.*id_flows" /usr/local/share/flows/ssh/config )
			if [ $cfgstatus -ne $cfganswer ]; then
				debug "Adding options to ~/.ssh/config"
				for c in ${CLUSTER//,/ }; do
					host=$( echo $c | cut -d/ -f2 | cut -d@ -f2 )
					if [ "$host" != ":" ]; then
						echo -e "Host $host*\n\tIdentityFile ~/.ssh/id_flows" >> ~/.ssh/config
					fi
				done
			else
				debug "SSH config is OK"
			fi
		else
			debug "Creating ~/.ssh/config file"
			cp /usr/local/share/flows/ssh/config ~/.ssh/
		fi
	else
		debug "Cluster execution has been disabled"
	fi
else
	debug "Parallel execution has been disabled"
fi

if [ -n "$fpm" -a $parallel -eq 1 -a $nocluster -eq 0 ]; then
	debug "Copying filter file contents to CLI"	
	cmd="echo \"$fpm\" | sed 's/^[ \\t]*//;s/[ \\t]*$//' | awk '{print \$2}'"
	ffile=$( eval $cmd );
	filter=$( cat $ffile 2>/dev/null | egrep -v "^#" | sed "s/#.*$//" | sed ':a;N;$!ba;s/\n/ /g' )
	if [ -n "$filter" ]; then
		debug "Contents of $ffile now transferred to CLI"
	else
		echo "[WARNING] Empty filter" >&2
	fi
fi

# Resolving hosts
if [ $nfresolve -eq 0 ]; then 
	debug "Resolving hosts"
	resolve "$filter"; 
else
	debug "Letting nfdump do hosts resolution on runtime"
fi

# Filter syntax check
if [ -n "$filter" ]; then
	debug "Verifying filter syntax"
	eval $BASE_NFDUMP_CMD -Z "\"$filter\"" &>/dev/null;
	if [ $? -ne 0 ]; then
		echo -e "[ERROR] Invalid filter syntax" >&2
		exit 1;
	else	
		fuse=1
		debug "Syntax OK"
	fi
else
	debug "Setting empty filter string"
	filter="";
fi

# Output search window
metafile="$TMP_DIR/$eid.meta"
debug "Metafile: $metafile"
if [ $quiet -eq 0 ]; then
	echo -e "\nTimestamp Now: "`date` | tee $metafile;
	if [ -n "$timeslot" ]; then
		echo "Searching in timeslot $timeslot $searchon" | tee -a $metafile;
	else
		echo "Searching between $sdir (${ts:0:2}:${ts:2:2}) and $edir (${te:0:2}:${te:2:2}) $searchon" | tee -a $metafile;
	fi
fi
if [ $verbose -ne 0 ]; then
	if [ -n "$timeslot" ]; then
		debug "Time window: $timeslot $searchon"
	else
		debug "Time window: $sdir (${ts:0:2}:${ts:2:2}) and $edir (${te:0:2}:${te:2:2}) $searchon" 
	fi
fi

# Output filter in use
if [ $fuse -eq 0 -a $ffuse -eq 0 ]; then 
	if [ $quiet -eq 0 ]; then
		echo -e "Filter: no filter in use\n" | tee -a $metafile 
	fi
else
	if [ $quiet -eq 0 ]; then
		if [ $fuse -eq 1 ]; then 
			echo -e "Filter: $filter\n" | tee -a $metafile
		else
			echo -e "Filter: Using filter files specified with -f option" | tee -a $metafile 
			for (( fi = 0 ; fi < ${#ffiles[@]} ; fi++ )); do
				finum=$(( fi + 1 ))
				echo -e "Filter file $finum: "${ffiles[$fi]} | tee -a $metafile
			done
			echo "" | tee -a $metafile
		fi
	fi
fi

# Add meta info to cache, if cache enabled
if [ $nocache -eq 0 ]; then
	if [ $quiet -eq 0 ]; then
		cat $metafile > $CACHE_DIR"/"$runtimesig;
	fi
fi

# Search on each defined probe
separator=$( seq -s "_" $WIDTH | sed 's/[0-9]//g' );
hits=0
for d in $list; do

	# Create command 
	path=$ROOT_FLOW_DIR'/'$d'/'$sdir'/'$sfile':'$edir'/'$efile;
	if [ "$filter" == "" ]; then
		command="$BASE_NFDUMP_CMD $proxy $apm $opm -R $path $spm $npm $qpm $fpm";
	else
		command="$BASE_NFDUMP_CMD $proxy $apm $opm -R $path $spm $npm $qpm $fpm \"$filter\"";
	fi
	if [ $nocolor -eq 0 ]; then
		# Colorize result
		command=$command" | gawk '{ match(\$0, /Summary: total flows: ([0-9]+),/, arr); if (arr[1] > \"0\"){num = \"[31mtotal flows: [1;31m\"arr[1]\"[0m\";}else{num = \"[32mtotal flows: [1;32m\"arr[1]\"[0m\";}sub(/Summary: total flows: [0-9]+,/,\"Summary: \"num,\$0)};{print}'";
	fi

	# Execute 
	if [ $parallel -eq 1 ]; then
		# Create execution queue
		qfile=$TMP_DIR/$eid".exec.queue"
		echo "echo $separator; echo \"$d\"; $command; echo \"Processed by \`hostname -f\`\"" >> $qfile
	else
		debug "Executing: $command"
		result=$( eval $command )
		if [ $hitsonly -eq 1 ]; then
			miss=`echo "$result" | egrep -c "^Summary: total flows: 0,"`
			if [ $miss -eq 1 ]; then
				continue;
			else
				let hits++
			fi
		fi
		if [ $quiet -eq 0 ]; then
			if [ $nocache -eq 1 ]; then
				echo -e "$separator\n$d\n";
			else
				echo -e "$separator\n$d\n" | tee -a $CACHE_DIR"/"$runtimesig;
			fi
		fi
		if [ $nocache -eq 1 ]; then
			echo "$result"
		else
			debug "Caching result"
			echo "$result" | tee -a $CACHE_DIR"/"$runtimesig
		fi
	
		if [ $quiet -eq 0 ]; then
			if [ $hitsonly -eq 0 ]; then
				echo -e "\n";
			fi
		fi
	fi

done; # For each probe

if [ $parallel -eq 1 ]; then
	numjobs=$( cat $qfile | wc -l )
	debug "Maximum char length on command line set to $max"
	debug "Queue file ($qfile) contains $numjobs jobs"
	if [ $nocluster -eq 0 ]; then
		debug "Parallel execution of $numjobs jobs on `echo $CLUSTER | sed 's/,/\n/g' | wc -l` cluster nodes"
		pcmd="parallel -j +0 --sshlogin $CLUSTER"
	else
		debug "Parallel execution of $numjobs jobs on this machine"
		pcmd="parallel -j +0"
	fi		
	if [ $hitsonly -eq 1 ]; then
		result=$( cat $qfile | $pcmd )
		echo "$result" > $TMP_DIR/$eid.res
		debug "Splitting result into separate files"
		splitres="cat $TMP_DIR/$eid.res | awk '/$separator/{n++}{print >\"$TMP_DIR/$eid.split\" n \".txt\" }'"
		eval $splitres
		for s in `ls $TMP_DIR/$eid.split*`; do
			miss=`cat $s | egrep -c "^Summary: total flows: 0,"`
			if [ $miss -eq 0 ]; then
				if [ $nocache -eq 1 ]; then
					cat $s
				else
					cat $s | tee -a $CACHE_DIR"/"$runtimesig
				fi
				let hits++
			fi
		done
	else
		if [ $nocache -eq 1 ]; then
			cat $qfile | $pcmd
		else
			debug "Caching result"
			result=$( cat $qfile | $pcmd )
			echo "$result" | tee -a $CACHE_DIR"/"$runtimesig

		fi
	fi
fi

if [ $quiet -eq 0 -a $hitsonly -eq 1 -a $hits -eq 0 ]; then
	echo "Nothing was found"
fi

if [ $verbose -lt 2 ]; then
	debug "Cleaning up tmp dir"
	command="rm -f $TMP_DIR/$eid* &>/dev/null";
	eval $command;
	if [ $? -ne 0 ]; then
		echo "[WARNING] Failed to remove $TMP_DIR/$eid*" >&2
	fi
else
	echo "[WARNING] Very verbose mode (-vv) prevents clean-up of tmp dir" >&2
fi

# Log command if possible	
if [ $do_log -eq 1 ]; then
	echo -e `date`";"$USER";"$cmdlog >> $CMD_LOG_FILE;
	if [ $? -eq 0 ]; then
		debug "Successfully logged current flows command"
	else
		echo "[WARNING] Failed to log current flows command"
	fi
fi

t_b=`date +%s`
let t_exe=t_b-t_a
debug "Execution time: $t_exe seconds"
